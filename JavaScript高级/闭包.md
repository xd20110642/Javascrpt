#闭包		
1. 什么是闭包:
 
	闭包就是函数中的函数(其他语言不能函数再套函数),里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。			
2. 闭包形成的条件
	* 函数的嵌套
	* 内部函数引用外部函数的局部变量
3. 闭包的特性
	* 每个函数都是闭包，每个函数天生都能够记忆自己定义时所处的作用域环境。
	
			//例题2
			function outer(x){
			  function inner(y){
			  console.log(x+y);
			  }
			return inner;
			}
			var inn=outer(3);//数字3传入outer函数后，inner函数中x便会记住这个值
			inn(5);//当inner函数再传入5的时候，只会对y赋值，所以最后弹出8
			
			//例题1
			var inner;
			function outer(){
			var a=250;
			inner=function(){
			alert(a);//这个函数虽然在外面执行，但能够记忆住定义时的那个作用域，a是250
			  }
			}
			outer();
			var a=300;
			inner();//一个函数在执行的时候，找闭包里面的变量，不会理会当前作用域。
4. 闭包的内存泄漏
	* 全局作用域----只有当页面关闭的时候全局作用域才会销毁
	* 私有的作用域----只有函数执行才会产生
	* **一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域中的代码执行完成后，我们当前作用域都会主动的进行释放和销毁。但当遇到函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的东西给接收了，这种情况下一般形成的私有作用域都不会销毁**	
	
				function fn(){
				var num=100;
				return function(){
				  }
				}
				var f=fn();//fn执行形成的这个私有的作用域就不能再销毁了
		闭包使用完了后，要立即释放资源，将引用变量指向null
		
		
				  function outer(){
			  var num=0;//内部变量
			  return function add(){//通过return返回add函数，就可以在outer函数外访问了
			  num++;//内部函数有引用，作为add函数的一部分了
			  console.log(num);
			  };
			 }
			  var func1=outer();
			  func1();//实际上是调用add函数， 输出1
			  func1();//输出2 因为outer函数内部的私有作用域会一直被占用
			  var func2=outer();
			  func2();// 输出1  每次重新引用函数的时候，闭包是全新的。
			  func2();// 输出2  


		